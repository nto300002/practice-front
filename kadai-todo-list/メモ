
     if(index > 3)return;
     const newTasks = [...tasks];
     newTasks[index].category++;
     setTasks(newTasks); 



      {isEditing ? (
                <form onSubmit={handleEditFormSubmit}>
                <h2>Edit Todo</h2>
                <label htmlFor="editTodo">Edit todo: </label>
                <input
                  name="editTodo"
                  type="text"
                  placeholder="Edit todo"
                  value={currentTodo.text}
                  onChange={handleEditInputChange}
                />
                <button type="submit">Update</button>
                <button onClick={() => setIsEditing(false)}>Cancel</button>
              </form>
      ):(
      <form onSubmit={handleSubmit}>
        <input value={item} placeholder='Enterを押してください' onChange={handleNewitem} />[追加]
      </form>
      )}








import React, { useState, useMemo } from "react";

export default () => {
  const initialState = {
    tasks: [
      {
        id: 1,
        title: "最初のタスク",
        category: 1
      },
      {
        id: 2,
        title: "2番目のタスク",
        category: 2
      },
      {
        id: 3,
        title: "3番目のタスク",
        category: 1
      }
    ],
    categories: [
      {
        id: 1,
        title: "カテゴリー1"
      },
      {
        id: 2,
        title: "カテゴリー2"
      }
    ]
  };

  // タスク
  const [tasks, setTasks] = useState(initialState.tasks);
  // カテゴリー
  const [categories, setCategories] = useState(initialState.categories);
  // 検索条件
  const [filterQuery, setFilterQuery] = useState({});
  // ソート条件
  const [sort, setSort] = useState({});
  const filteredTask = useMemo(() => {
    let tmpTasks = tasks;

    // 入力した文字は小文字にする
    const filterTitle = filterQuery.title && filterQuery.title.toLowerCase();

    // 絞り込み検索
    tmpTasks = tmpTasks.filter((row) => {
      // タイトルで絞り込み
      if (
        filterQuery.title &&
        String(row.title).toLowerCase().indexOf(filterTitle) === -1
      ) {
        return false;
      }

      // カテゴリーで絞り込み
      if (
        filterQuery.category_id &&
        row.category !== parseInt(filterQuery.category_id)
      ) {
        return false;
      }
      return row;
    });

    // ソート
    if (sort.key) {
      tmpTasks = tmpTasks.sort((a, b) => {
        a = a[sort.key];
        b = b[sort.key];
        return (a === b ? 0 : a > b ? 1 : -1) * sort.order;
      });
    }

    return tmpTasks;
  }, [filterQuery, sort, tasks]);

  // 入力した情報をfilterQueryに入れる
  const handleFilter = (e) => {
    const { name, value } = e.target;
    setFilterQuery({ ...filterQuery, [name]: value });
  };

  // 選択したカラムをSortに入れる
  const handleSort = (column) => {
    if (sort.key === column) {
      setSort({ ...sort, order: -sort.order });
    } else {
      setSort({
        key: column,
        order: 1
      });
    }
  };

  return (
    <div className="wrap">
      <div className="filter-box">
        <div className="input-group">
          <input
            type="text"
            name="title"
            className="form-input"
            placeholder="タイトル"
            value={filterQuery.title || ""}
            onChange={handleFilter}
          />
        </div>
        <div className="input-group">
          <div className="selectbox">
            <select
              name="category_id"
              value={filterQuery.category_id}
              onChange={handleFilter}
            >
              <option value="">カテゴリー選択</option>
              {categories.map((item) => {
                return (
                  <option key={item.id} value={item.id}>
                    {item.title}
                  </option>
                );
              })}
            </select>
          </div>
        </div>
      </div>

      <table>
        <thead>
          <tr>
            <th onClick={() => handleSort("id")}>ID</th>
            <th>タイトル</th>
            <th onClick={() => handleSort("category")}>カテゴリー</th>
          </tr>
        </thead>
        <tbody>
          {filteredTask.map((task) => {
            return (
              <tr key={task.id}>
                <td>{task.id}</td>
                <td>{task.title}</td>
                <td>
                  {task.category
                    ? categories.find((c) => c.id === task.category).title
                    : ""}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
};


--------------

import React,{useState, useMemo} from 'react';
import { v4 as uuidv4 } from 'uuid';

function App() {

  const status = [
    { id: 1,title: '未着手'},
    {id: 2,title: '進行中'},
    {id: 3,title: '完了'}
]
  const task = [{}]

const defaultItem = () => ({ id: new Date().getTime(), title: "", text: "", status: "未着手" });
const [items, setItems] = React.useState([defaultItem()]);
const [length, setLength] = React.useState(1);

const handleFilter = e => {
  const { name, value } = e.target;
  setFilterQuery({ ...filterQuery, [name]: value });  
};

const addItem = () => {
  if (length > 8) return;
  setItems((items) => [...items, defaultItem()]);
  setLength((length) => length + 1);
};
const deleteItem = ({ target: { name } }) => {
  const newItemArray = [...items];
  newItemArray.splice(Number(name), 1);
  setItems(newItemArray);
  setLength((length) => length - 1);
};




  const [tasks, setTasks] = useState([]);
  const [statuses, setStatus] = useState(status);
  


  const [filterQuery, setFilterQuery] = useState({});



  const filteredTask = useMemo(() => {
    let tmpTasks = items;
    tmpTasks = tmpTasks.filter(row => {

      // カテゴリーで絞り込み
      if (
          filterQuery.status_id &&
          row.status !== parseInt(filterQuery.status_id)
      ) {
          return false;
      }
      return row;
  });
  return tmpTasks;
  }, [filterQuery, items]);


  

  const handleFilter = e => {
    const { name, value } = e.target;
    setFilterQuery({ ...filterQuery, [name]: value });  
};


  return (                
  <div className="selectbox">
  
  <select
      name="status_id"
      value={filterQuery.status_id}
      onChange={handleFilter}
  >
      <option value="">全て表示</option>
      {
          statuses.map((item) => {
              return (
                <>
                  <option
                      key={item.id}
                      value={item.id}>
                      {item.title}
                  </option>
                  

                </>
              );
          })
      }
  </select>
  <input type="text" name="a" defaultValue={items.title} placeholder='title'/>
  <input type="text" name="a" defaultValue={items.title} placeholder='text'/>
  <button onClick={addItem} disabled={length > 8 ? true : false}>
        Add item
      </button>
      {
        filteredTask.map((item, index) => {
          return (
            <ul key={item.id}>
              <li>{index + 1}{items.title}          <button onClick={deleteItem} name={index.toString()}>
            ×
          </button></li>
              <span>               
                {task.status
                    ? statuses.find((c) => c.id === task.status).title
                    : ""}
              </span>
              
            </ul>
          )
        })
      }
</div>

)

}









export default App





import { useEffect, useState } from "react";
import "./styles.css";

export default function App() {
  const [todos, setTodos] = useState(() => {
    const savedTodos = localStorage.getItem("todos");
    if (savedTodos) {
      return JSON.parse(savedTodos);
    } else {
      return [];
    }
  });
  const [todo, setTodo] = useState("");
  // boolean state to know if we are editing (this will let us display
  // different inputs based on a condition (conditional rendering)
  const [isEditing, setIsEditing] = useState(false);
  // object state to set so we know which todo item we are editing
  const [currentTodo, setCurrentTodo] = useState({});

  useEffect(() => {
    localStorage.setItem("todos", JSON.stringify(todos));
  }, [todos]);

  function handleInputChange(e) {
    setTodo(e.target.value);
  }

  // function to get the value of the edit input and set the new state
  function handleEditInputChange(e) {
    // set the new state value to what's currently in the edit input box
    setCurrentTodo({ ...currentTodo, text: e.target.value });
    console.log(currentTodo);
  }

  function handleFormSubmit(e) {
    e.preventDefault();

    if (todo !== "") {
      setTodos([
        ...todos,
        {
          id: todos.length + 1,
          text: todo.trim()
        }
      ]);
    }

    setTodo("");
  }

  function handleEditFormSubmit(e) {
    e.preventDefault();

    handleUpdateTodo(currentTodo.id, currentTodo);
  }

  function handleDeleteClick(id) {
    const removeItem = todos.filter((todo) => {
      return todo.id !== id;
    });
    setTodos(removeItem);
  }

  // function to edit a todo item
  function handleUpdateTodo(id, updatedTodo) {
    // here we are mapping over the todos array - the idea is check if the todo.id matches the id we pass into the function
    // if the id's match, use the second parameter to pass in the updated todo object
    // otherwise just use old todo
    const updatedItem = todos.map((todo) => {
      return todo.id === id ? updatedTodo : todo;
    });
    // set editing to false because this function will be used inside a onSubmit function - which means the data was submited and we are no longer editing
    setIsEditing(false);
    // update the todos state with the updated todo
    setTodos(updatedItem);
  }

  // function to handle when the "Edit" button is clicked
  function handleEditClick(todo) {
    // set editing to true
    setIsEditing(true);
    // set the currentTodo to the todo item that was clicked
    setCurrentTodo({ ...todo });
  }

  return (
    <div className="App">
      {/* We need to conditionally render different inputs based on if we are in editing mode */}
      {isEditing ? (
        // if we are editing - display the edit todo input
        // make sure to add the handleEditFormSubmit function in the "onSubmit" prop
        <form onSubmit={handleEditFormSubmit}>
          {/* we've added an h2 element */}
          <h2>Edit Todo</h2>
          {/* also added a label for the input */}
          <label htmlFor="editTodo">Edit todo: </label>
          {/* notice that the value for the update input is set to the currentTodo state */}
          {/* also notice the handleEditInputChange is being used */}
          <input
            name="editTodo"
            type="text"
            placeholder="Edit todo"
            value={currentTodo.text}
            onChange={handleEditInputChange}
          />
          {/* here we added an "update" button element - use the type="submit" on the button which will still submit the form when clicked using the handleEditFormSubmit function */}
          <button type="submit">Update</button>
          {/* here we added a "Cancel" button to set isEditing state back to false which will cancel editing mode */}
          <button onClick={() => setIsEditing(false)}>Cancel</button>
        </form>
      ) : (
        // if we are not editing - display the add todo input
        // make sure to add the handleFormSubmit function in the "onSubmit" prop
        <form onSubmit={handleFormSubmit}>
          {/* we've added an h2 element */}
          <h2>Add Todo</h2>
          {/* also added a label for the input */}
          <label htmlFor="todo">Add todo: </label>
          {/* notice that the value is still set to the todo state */}
          {/* also notice the handleInputChange is still the same */}
          <input
            name="todo"
            type="text"
            placeholder="Create a new todo"
            value={todo}
            onChange={handleInputChange}
          />
          {/* here we just added a "Add" button element - use the type="submit" on the button which will still submit the form when clicked using the handleFormSubmit function */}
          <button type="submit">Add</button>
        </form>
      )}

      <ul className="todo-list">
        {todos.map((todo) => (
          <li key={todo.id}>
            {todo.text}
            {/* we are passing the entire todo object to the handleEditClick function*/}
            <button onClick={() => handleEditClick(todo)}>Edit</button>
            <button onClick={() => handleDeleteClick(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}



item todo
